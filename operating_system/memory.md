## 内存管理

### 内存管理的发展过程

DOS时代 - 同一时间只能有一个进程在运行（也有一些特殊算法可以支持多进程）

windows9x - 多个进程装入内存，存在问题：

​		1）内存不够用 

​		2）进程之前互相打扰

为了解决这两个问题，诞生了现在的内存管理系统：虚拟地址、分页装入、软硬件结合寻址

1. 分页（内存不够用），内存中分成固定大小的页框（4K），把程序（硬盘上）分成4K大小的块，用到哪一块，加载那一块，加载的过程中，如果内存已经满了，会把最不常用的一块放到swap分区， 把最新的一块加载进来，这个就是著名的LRU算法

   ​		1）LRU算法 LeetCode146题，头条要求手撕，阿里去年也要求手撕

   ​		2）Least Recently Used 最不常用

   ​		3）哈希表（保证 查找操作O(1)） + 链表 （保证 排序操作和新增操作 O(1)））

   ​		4）双向链表 （保证 左边指针 指向右边块）

2. 虚拟内存（解决相互打扰问题）

   1）DOS Win31 ... 互相干掉

   2）为了保证互不影响 - 让进程工作在虚拟空间，程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样，A进程永远不可能访问到B进程的空间

   3）虚拟空间多大呢？寻址空间 - 64位系统 2 ^ 64，比物理空间大很多 ，单位是byte

   4）站在虚拟的角度，进程是独享整个系统 + CPU

   5）内存映射：偏移量 + 段的基地址 = 线性地址 （虚拟空间）

   6）线性地址通过 OS + MMU（硬件 Memory Management Unit）

3. 缺页中断（不是很重要）：

   需要用到页面内存中没有，产生缺页异常（中断），由内核处理并加载

### ZGC

算法叫做：Colored Pointer

GC信息记录在指针上，不是记录在头部， immediate memory use

42位指针 寻址空间4T JDK13 -> 16T 目前为止最大16T 2^44

### CPU如何区分一个立即数 和 一条指令

总线内部分为：数据总线、地址总线、控制总线

地址总线目前：48位

颜色指针本质上包含了地址映射的概念

## 内核同步过程

### 关于同步理论的一些基本概念

• 临界区（critical area）: 访问或操作共享数据的代码段。 简单理解：synchronized大括号中部分（原子性）

• 竞争条件（race conditions）两个线程同时拥有临界区的执行权

• 数据不一致：data unconsistency 由竞争条件引起的数据破坏

 •同步（synchronization）避免race conditions

• 锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在），上锁解锁必须具备原子性

• 原子性（像原子一样不可分割的操作）

• 有序性（禁止指令重排）

• 可见性（一个线程内的修改，另一个线程可见）

互斥锁 排他锁 共享锁 分段锁

### 内核同步常用方法

1.原子操作 – 内核中类似于AtomicXXX，位于<linux/types.h>

2.自旋锁 – 内核中通过汇编支持的cas，位于<asm/spinlock.h>

3.读-写自旋 – 类似于ReadWriteLock，可同时读，只能一个写，读的时候是共享锁，写的时候是排他锁

4.信号量 – 类似于Semaphore(PV操作 down up操作 占有和释放） 重量级锁，线程会进入wait，适合长时间持有的锁情况

5.读-写信号量 – downread upread downwrite upwrite （多个写，可以分段写，比较少用）(分段锁）

6.互斥体(mutex) – 特殊的信号量（二值信号量）

7.完成变量 – 特殊的信号量（A发出信号给B，B等待在完成变量上） vfork() 在子进程结束时通过完成变量叫醒父进程 类似于(Latch)

8.BKL：大内核锁（早期，现在已经不用）

9.顺序锁（2.6）： – 线程可以挂起的读写自旋锁 序列计数器（从0开始，写时增加(+1)，写完释放(+1)，读前发现单数， 说明有写线程，等待，读前读后序列一样，说明没有写线程打断）

10.禁止抢占 – preempt_disable()

11.内存屏障 – 见volatile

## 汇编实现引导程序

### 编写汇编码

```asm

; 文件名 boot.asm
 
org 7c00h                     ; BIOS读入MBR后，从0x7c00h处开始执行
 
; 下面部分和10h有关中断，10h中断用来显示字符
mov ax, cs
mov es, ax
mov ax, msg
mov bp, ax                    ; ES:BP表示显示字符串的地址
mov cx, msgLen                ; CX存字符长度
mov ax, 1301h                 ; AH=13h表示向TTY显示字符，AL=01h表示显示方式（字符串是否包含显示属性，01h表示不包含）
mov bx, 000fh                 ; BH=00h表示页号，BL=0fh表示颜色
mov dl, 0                     ; 列
int 10h
  
msg: db "hello world, welcome to OS!"
msgLen: equ $ - msg           ; 字符串长度
times 510 - ($ - $$) db 0     ; 填充剩余部分
dw 0aa55h                     ; 魔数，必须有这两个字节BIOS才确认是MBR
```

## 编译

nasm boot.asm -o boot.bin

## 制作启动软盘

1. dd if=/dev/zero of=floppy.img bs=1474560 count=1 **生成空白软盘镜像**
2. dd if=boot.bin of=myos.img bs=512 count=1 **制作包含主引导记录boot.bin的启动镜像文件**
3. dd if=floppy.img of=myos.img skip=1 seek=1 bs=512 count=2879 **在 bin 生成的镜像文件后补上空白，成为合适大小的软盘镜像，一共2880个扇区，略过第一个**

## 用软盘启动系统

1. 将myos.img下载到windows
2. VMWare创建空的虚拟机
   1. 文件 - 创建新的虚拟机 - 典型
   2. 稍后安装操作系统
   3. 其他
   4. 一路next 完成
   5. 虚拟机设置，去掉CD/DVD选项中“启动时连接”
   6. 网络，选择“仅主机模式”，勾选“启动时连接”（好像无所谓）
   7. 添加软盘驱动器 使用软盘映像 找到myos.img
3. 启动虚拟机

## 为什么是0x7C00?

https://www.glamenv-septzen.net/en/view/6